# Keyball Gestures アーキテクチャ設計

このドキュメントでは、Keyball Gesturesのアーキテクチャと内部設計について説明します。

## 全体アーキテクチャ

Keyball Gesturesは、CLIアプリケーションとAPIサーバーの2つの動作モードを持つバックエンドシステムとして設計されています。バックエンドはFlutterで構築されたフロントエンドアプリケーションと連携することを想定しています。

```
┌─────────────────┐     ┌─────────────────┐
│                 │     │                 │
│  Flutter        │     │  CLI モード     │
│  フロントエンド │     │  (スタンドアロン)│
│                 │     │                 │
└────────┬────────┘     └─────────────────┘
         │                        ▲
         │ HTTP API               │
         ▼                        │
┌─────────────────┐               │
│                 │               │
│  API サーバー   │───────────────┘
│  モード         │  内部API呼び出し
│                 │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│                 │
│  ジェスチャー   │
│  認識サービス   │
│                 │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│                 │
│  Linux入力      │
│  サブシステム   │
│  (/dev/uinput)  │
└─────────────────┘
```

## 主要コンポーネント

### 1. コマンドライン (cmd/main.go)

エントリーポイントとなるコンポーネント。コマンドライン引数を解析し、CLIモードかAPIサーバーモードのどちらかで起動します。設定ファイルのロードや基本的な初期化処理も担当します。

### 2. 設定管理 (internal/config)

設定ファイル（TOML形式）の読み込み、保存、デフォルト値の提供を担当します。以下の設定項目をサポートしています：

- タッチパッド設定（範囲など）
- 入力設定（トリガーキー）
- モーション設定（フィルター係数など）
- ジェスチャー設定（リセット閾値など）
- デバイス設定（優先デバイス）

### 3. APIサーバー (internal/api)

HTTPベースのRESTful APIを提供し、外部（特にFlutterフロントエンド）からのリクエストを処理します。

- **server.go**: HTTPサーバーの初期化と管理。設定の保持と更新も担当。
- **routes.go**: APIエンドポイントのルーティングとハンドラ実装。各エンドポイントは `GestureService` や設定操作を呼び出す。
- **service.go**: ジェスチャー認識サービスのコアロジック。デバイスの初期化、ジェスチャーループの実行、デバイス監視、自動再接続、健全性チェックなどを担当。

### 4. 機能モジュール (internal/features)

ジェスチャー認識の中核となる機能を実装します：

- **devices.go**: 入力デバイスの検出、管理、監視 (`DeviceMonitor`)。デバイスの接続/切断イベントの処理、デバイスのスキャン/再スキャン機能を提供。
- **keyboard.go**: 物理キーボード入力の読み取りと処理。
- **mouse.go**: 物理マウス（トラックボール）入力の読み取りと処理。デバイスのグラブ/リリース機能も含む。
- **touchpad.go**: Linux uinput を利用した仮想タッチパッドデバイスの作成とイベント送信。
- **motion_filter.go**: マウス移動量の平滑化（スムージング）フィルター。

### 5. 型定義とユーティリティ (internal/types, internal/utils)

汎用的な型定義やユーティリティ関数を提供します。

## データフロー

### 1. CLIモード

1. ユーザーがCLIモードでアプリケーションを起動
2. 設定ファイルをロード
3. 入力デバイス（キーボード、マウス）を検出
4. 仮想タッチパッドデバイスを作成
5. トラックボール（マウス）からの入力を監視し、特定のキー（F13/F14）と組み合わせてジェスチャーとして解釈
6. ジェスチャーを仮想タッチパッドイベントに変換
7. 仮想タッチパッドイベントをLinuxのuinputシステムに送信

### 2. APIサーバーモード

1. ユーザーがAPIサーバーモードでアプリケーションを起動
2. HTTPサーバーを初期化（デフォルトポート：8080）
3. APIエンドポイントを設定
4. クライアント（Flutterフロントエンド）からのリクエストを待機
5. リクエストに応じて以下の処理を実行：
   - 設定の取得/更新/保存
   - デバイス一覧の取得
   - ジェスチャー認識サービスの開始/停止
   - サービス状態の取得

### ジェスチャー認識サービス (共通)

1.  **初期化**:
    *   設定に基づき仮想タッチパッドデバイスを作成。
    *   物理キーボードとマウスデバイスを検出（優先デバイス設定を考慮）。
    *   検出したデバイスをオープン。
    *   デバイスモニターを初期化し、デバイスの接続/切断イベントの監視を開始。
2.  **メインループ**:
    *   物理キーボードとマウスから入力を継続的に読み取る。
    *   モーションフィルターを適用してマウス移動量を平滑化。
    *   設定されたトリガーキーとマウス移動の組み合わせからジェスチャー（2本指/4本指）を認識。
    *   認識したジェスチャーに対応する仮想タッチパッドイベント（指の接触、移動、離脱）を生成。
    *   生成したイベントをuinputシステムに送信。
    *   設定の動的更新をチェックし、反映。
3.  **デバイス監視**:
    *   バックグラウンドでデバイスの接続/切断イベントを監視。
    *   監視対象のデバイスが切断された場合、自動再接続処理をトリガー。
4.  **自動再接続**:
    *   デバイス切断時に、一定回数デバイスの再スキャンと再オープンを試行。
    *   再接続成功後、ジェスチャーループは新しいデバイスで処理を継続。
5.  **健全性チェック**:
    *   定期的に（例: 5秒ごと）オープン中のデバイスが応答するか確認。
    *   応答がない場合、デバイスが利用不可と判断し、自動再接続処理をトリガー。

## 設定ファイル

設定はTOML形式で、`~/.config/keyball-gestures/config.toml`（デフォルト）に保存されます。設定ファイルは以下のセクションで構成されています：

```toml
[touchpad]
min_x = 0
max_x = 32767
min_y = 0
max_y = 32767

[input]
two_finger_key = 184  # F14
four_finger_key = 183  # F13

[motion]
filter_smoothing_factor = 0.85
filter_warm_up_count = 10
mouse_delta_factor = 15

[gesture]
reset_threshold = "50ms"

[device_prefs]
preferred_keyboard_device = ""
preferred_mouse_device = ""
```

## Flutterフロントエンドとの連携

Flutterフロントエンドは、APIサーバーモードで動作するKeyball Gesturesバックエンドと連携します。主な連携ポイントは以下の通りです：

1. **設定管理**: フロントエンドから設定を取得/更新
2. **デバイス選択**: 利用可能なデバイス一覧を取得し、ユーザーにデバイスを選択させる
3. **サービス制御**: ジェスチャー認識サービスの開始/停止を制御
4. **状態確認**: サービスの現在の状態 (`running`/`stopped`) やサーバーの健全性 (`/api/health`) を取得

フロントエンドはHTTP APIを通じてこれらの操作を行い、バックエンドはRESTful APIとして実装されています。
